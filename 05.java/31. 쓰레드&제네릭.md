# 31. 쓰레드&제네릭

### 01. 쓰레드

> `Program` vs `Process` vs `Thread`
>
> - 컴퓨터에서 작업을 수행하는 기본단위
>
> 1. **프로그램**
>    - 실행가능한 명령어의 집합, 특정 작업을 수행하기 위해 작성된 코드. 일반적으로 소스코드 형태로 존재
>    - *예) 파일*
> 2. **프로세스**
>    - 실행 중인 프로그램의 인스턴스로 운영 체제에 의해 관리 됨
>    - 코드, 데이터, 스택, 힙 등 메모리 공간 포함
>    - 각 프로세스는 고유한 주소공간을 가짐
>    - 독립적이고 다른 프로세스와 메모리를 공유 X
>      - 여러 프로세스가 동시에 실행 가능
>    - *예) 웹 브라우저를 실행할 때 생성되는 프로세스*
> 3. **스레드**
>    - 프로세스 내에서 실행되는 경량의 실행 단위로, 프로세스의 일부로서 작업을 수행
>    - 프로세스 내의 메모리 공간을 공유
>    - 스레드 간의 전환이 빠르고 프로세스 내에서 데이터를 쉽게 공유
>      - 스레드가 서로 영향을 미칠 수 있어 동기화 필요
>    - *예) 웹 브라우저의 각 탭이 별도의 스레드로 실행되는 경우*
>
> **요약**
>
> - **프로그램** 실행 가능한 코드 (정적)
> - **프로세스** 실행 중인 프로그램의 인스턴스 (동적, 독립적)
> - **스레드** 프로세스 내에서 실행되는 경량 작업 단위 (동적, 공유 메모리)



- **multi tasking**
  - 동시에 여러작업을 수행하는 것
- **mulit process**
  - process를 여러개 띄워서 멀티태스킹을 수행
- **multi thread**
  - thread를 여러개 띄워서 멀티태스킹을 수행

\* 자바의 thread는 process안에 여러개 생성 가능
(Main Thread가 기본 쓰레드)



#### 1-1. 생성 및 실행

1. **생성**

   - Thead class 상속받아 `run()`메서드 재정의
     또는

   - Runnable interface 구현(추상 메서드(`run()` 구현)

     - Thread 생성자로 Runnable 객체 전달

     ```java
     class MyRunnable implements Runnable{
       @Override
       public void run(){
         // 쓰레드 작업내용
       }
     }
     ```

     - 객체 생성

     ```java
     Runnable r=new MyRunnable();
     // 또는
     MyRunnable r=new MyRunnable();
     Thread myThread=new Thread(r);
     ```

     ​

2. **실행**

   - Thread 객체내의 `start()`(JVM Thread 등록) 메서드 호출

     ```java
     myThread.start();
     ```

     ​

3. **주의**

   - 재정의한 메서드는 `run()` 이지만 `Thread`의 실행은 `start()` 메서드 호출
   - Thread 객체는 재사용 X
     - 하나의 객체는 <u>한번만 `start()` 가능</u>



**\* JVM이 thread를 관리, 실행**

- thread를 random하게 돌아가면서 실행
- 주기적으로 돌아가면서 처리 
  (우선순위가 높은 쓰레드가 더 자주 실행 됨) - 점유율이 더 높음

```java
class MyThread extends Thread{
	@Override
	public void run() {
		// 쓰레드가 해야할 일
		for(;;) {
			System.out.println("Thread 1");
		}
	}
}
class MyThread2 extends Thread{
	// 쓰레드가 해야할 일
	@Override
	public void run() {
		for(;;) {
			System.out.println("Thread 2");
		}
	}
}
public class ThreadTest {

	public static void main(String[] args) {
		MyThread t1=new MyThread();
		t1.start(); // t1을 JVM에 등록. run()메서드가 바로 실행되는 것이 아님
		MyThread2 t2=new MyThread2();
		t2.start(); // t2을 JVM에 등록. run()메서드가 바로 실행되는 것이 아님
		
		// 1과 2가 번갈아 출력(동시에 출력되고 있는 것)
	}
}
```

- Multi Thread 사용 예
  1. 채팅 프로그램
     - send, recieve가 동시에 되어야 함
  2. 게임
     - 아군, 적군, 총알이 모두 개별적으로 움직어야 함
  3. 다운로드
     - 다운로드 작업을 별개의 쓰레드로 구현 



> **Thread 특징**
>
> - 먼저 `start()` 된 쓰레드의 작업이 먼저 완료된다는 보장이 없음
> - 먼저 `start()` 된 쓰레드 작업 항상 먼저 시작된다는 보장이 없음
> - 두 쓰레드 작업이 무한반복된다면 결국 같은 점유율로 처리 됨 (우선순위가 같을 때)
>   - 우선순위가 높은 쓰레드가 점유율이 더 높다
> - 쓰레드는 주로 무한루프 작업을 많이 함



> **예외처리가 필요한 작업**
>
> 1. Thread
> 2. File I/O
> 3. Network I/O
> 4. DB I/O

```java
class MyThread extends Thread{
	@Override
	public void run() {
		// 쓰레드가 해야할 일
		for(int i=0; i<100; i++) {
			System.out.println("Thread 1");
          // 예외처리 추가
			try {
				Thread.sleep(1000); // 1초 연기
			}catch(InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
class MyThread2 extends Thread{
	// 쓰레드가 해야할 일
	@Override
	public void run() {
		for(int i=0; i<100; i++) {
			System.out.println("Thread 2");
            // 예외처리 추가
			try {
				Thread.sleep(1000); // 1초 연기
			}catch(InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
public class ThreadTest {

	public static void main(String[] args) {
		MyThread t1=new MyThread();
		t1.start(); // t1을 JVM에 등록. run()메서드가 바로 실행되는 것이 아님
		MyThread2 t2=new MyThread2();
		t2.start(); // t2을 JVM에 등록. run()메서드가 바로 실행되는 것이 아님
	}
}
```

```java
// 출력
Thread 1
Thread 2
Thread 1
Thread 2
Thread 1
Thread 2
Thread 2
Thread 1
...
```



**Thread class** 는 `class` 이므로 상속받으면 다른 클래스를 더이상 상속받을 수 없음(다중상속 안됨)

**Runnable interface** 는 `interface`이므로 다른 클래스를 상속받을 수 있음(다중상속 됨)



### 02. 쓰레드 속성

1. Thread 객체 가져오기 (Thread 클래스의 정적 메서드)

   - Thread 참조 객체가 없는경우 `.currentThread()` 사용

2. Thread 이름설정 및 가져오기  (Thread 클래스의 인스턴스 메서드)

   -  `setName(String name)`
   -  `getName()`

3. Thread 개수 (Thread 클래스의 정적 메서드)

   - `activeCount()`

4. 우선순위  (Thread 클래스의 인스턴스 메서드) :star::star::star:

   - `getPriority()` 가져오기
   - `setPriority()` 정하기
   - **우선순위(Priority)** 동시성(concurrency)을 가지고 동작시 할당되는 time slot에 비례하는 값

5. 데몬 설정  (Thread 클래스의 인스턴스 메서드)

   - main thread가 종료되면 같이 종료되는 쓰레드


   - `setDaemon(boolean on)`

     - ture인경우 Daemon Thread


     - Default 값은 flase : 일반 Thread

   ```java
   class MThread implements Runnable{
   	@Override
   	public void run() {
   		// 쓰레드가 해야할 일
   		for(int i=0; i<10000; i++) {
   			System.out.println("Thread 1");
   			try {
   				Thread.sleep(1000);
   			}catch(InterruptedException e) {
   				e.printStackTrace();
   			}
   		}
   	}
   }
   public class ThreadTest2 {

   	public static void main(String[] args) {
   		MThread t1=new MThread();
   		Thread mythread1=new Thread(t1);
   		mythread1.setDaemon(true); // 데몬쓰레드로 설정(start()전에 호출)
   		mythread1.start(); // t1을 JVM에 등록. run()메서드가 바로 실행되는 것이 아님
   		
   		// 일반쓰레드는 다른 쓰레드 종료여부와 상관없이 자신의 작업이 종료될 때까지 계속 수행
   		// 모든 일반쓰레드(사용자쓰레드)가 모두 종료되면 작업이 완료디지 않았어도 함께 종료
   		System.out.println("main쓰레드 종료");
   	}
   }
   ```

   ​

### 03. 쓰레드 동기화

- Thread Synchronization
  - 공유데이터가 있을 때 쓰레드가 순서대로 공유데이터를 사용하는 것
  - java는 동시적인 실행 모델을 가지고 있지만, 쓰레드는 멀티쓰레딩 환경에서 스레드 간의 동기화를 보장하기 위해 사용
    - 멀티스레드 프로그래밍에서는 여러 스레드가 동시에 실행되기 때문에 데이터의 일관성을 유지하고 경쟁 상태(Race Condition)를 방지하기 위해 동기화가 필요

> **동기화**
>
> - 개념
>
>   - 하나의 작업이 완전히 완료된 후 다른 작업을 수행하는 것
>
>     \* 비동기는 하나의 작업 명령 이후 완료 여부와 상관없이 바로 다른 작업 명령을 수행하는 것을 말한다.
>
> - 필요성
>
>   - 어떤 함수가 먼저 오냐에 따라 결괏값이 바뀌므로 순서대로 작동할 수 있도록 다음 함수가 기다려야 한다.

1. 메서드 동기화

   - 2개의 쓰레드가 동시에 메서드를 실행할 수 없는 것

     ```java
     접근 지정자 synchronized 리턴타입 메서드명(입력매개변수){
       // 동기화가 필요한 코드
     }
     ```

     ​

2. 블록 동기화

   - 2개의 쓰레드가 동시에 해당 블록을 실행할 수 없다는 것을 의미

     ```java
     class MyData{
       	sychronized(임의의객체){// Key를 가진 객체
       	// 동기화가 필요한 코드
     	}
     }
     ```

     - Key를 가진 객체(모든 객체는 저마다의 Key 하나를 가지고 있음)
     - 일반적으로 클래스 내부에서 바로 사용할 수 있는 객체인 `this`를 사용




### 04. 쓰레드 상태

**Life cycle 생명주기**

1. 객체 생성 `new`
2. `timed wating` 
   - `sleep()`
   - `interrupt()`
   - 시간이 지나면 자동 실행 
3. blocked
   - 사용객체 잠금/풀림
4. wating
   - `join()` `wait()`
   - `notify()` `notifyAll()`
   - 직접 풀어줘야 실행
   - `wait()`  `notify()` `notifyAll()` 은 <u>동기화 블록에서만</u> 사용가능
5. 완료 `terminated`

