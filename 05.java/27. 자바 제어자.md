# 27. 자바 제어자

### 01. 접근 지정자

- 멤버 및 생성자의 접근지정자
  1. public
     - 공개 -  자유롭게 접근 가능
  2. protected
     - 같은 패키지 + 자식(패키지가 달라도)에게 공개
  3. default 
     - 아무것도 기재하지 않은 상태
     - 같은 패키지 안에서만 공개
  4. private
     - 비공개 - class 외부에서 접근 불가



- *예제)*

  ```java
  // class A
  package abc;

  public class A {
  	public int a=1;
  	protected int b=2;
  	int c=3;
  	private int d=4;
  	
  	public void print() {
  		System.out.print(a+" ");
  		System.out.print(b+" ");
  		System.out.print(c+" ");
  		System.out.print(d+" ");
  		System.out.println();
  	}
  }
  ```

  ``` java
  // class B
  package abc;

  public class B {
  	public void print() {
  		// 객체 생성
  		A a=new A();
  		
  		//멤버 활용
  		System.out.print(a.a+" "); // 클래스 A는 같은 패키지에 있으므로 public, protected, default 접근 지정자로 지정된 필드는 접근 가능
  		System.out.print(a.b+" ");
  		System.out.print(a.c+" ");
  		// System.out.print(a.d+" "); // private 접근지정자로 지정된 필드는 접근 불가
  		System.out.println();
  	}
  }
  ```

  ```java
  // class C
  package bcd;

  import abc.A;

  public class C {
  	public void print() {
  		// 객체 생성
  		A a=new A();
  		
  		// 멤버 활용
  		System.out.print(a.a+" ");
  		// 다른 패키지 내의 클래스에서는 자식 클래스가 아닐 때는 public 접근 지정자만 사용 가능
  		// System.out.print(a.b+" ");
  		// System.out.print(a.c+" ");
  		// System.out.print(a.d+" "); 
  		System.out.println();
  	}
  }
  ```

  ```java
  // class D
  package bcd;

  import abc.A;

  public class D extends A { // D클래스는 A클래스의 자식 클래스
  	public void print() {
  		// 멤버 활용
  		System.out.print(a+" ");
  		System.out.print(b+" ");
  		// 자식 클래스는 다른 패키지에 있어도 객체의 생성 없이 protected 접근 지정자 필드까지 접근 가능
  		// System.out.print(c+" ");
  		// System.out.print(d+" "); 
  		System.out.println();	
  	}	
  }
  ```

  - 클래스 생성 후,

    ``` java
    package com.naver.ex01;

    // 서로 다른 패키지에 있는 ABCD 임포트
    import abc.A;
    import abc.B;
    import bcd.C;
    import bcd.D;

    public class AccessModifierOfMember {

    	public static void main(String[] args) {
    		A a=new A();
    		B b=new B();
    		C c=new C();
    		D d=new D();
    		
    		a.print();
    		b.print();
    		c.print();
    		d.print();		
    	}
    }
    ```

    ```java
    // 출력
    1 2 3 4 
    1 2 3 
    1 
    1 2 
    ```

    ​


### 02. `static` 제어자

- **인스턴스 멤버**

  - 객체 안에 있을 때 사용할 수 있는 상태가 되는 멤버
  - 객체 생성 후, `참조변수명.멤버명` 으로 사용
  - `static`이 붙어있지 않은 멤버

- **정적 멤버**

  - `클래스명.멤버명` 으로 사용


  - `static`이 붙어있는 멤버

  - <u>객체간 공유 변수의 성질</u>

    ​

#### 2-1 인스턴스 필드vs 정적 필드

```java
class A {
  int m=2;
  static int n=5;
}

public static void main(String[] args){
  A a1=new A();
  A a2=new A();
  
  // 인스턴스 필드
  a1.m=5;
  a2.m=6;
  System.out.println(a1.m); // 5
  System.out.println(a2.m); // 6
  
  // 정적(static) 필드
  a1.n=7;
  a2.n=8;
  System.out.println(a1.n); // 8
  System.out.println(a2.n); // 8
}
```



#### 2-2. 인스턴스 메서드 vs 정적 메서드

```java
class A{
  // 객체를 생성한 후에 사용 가능
  // A a=new A();
  // a.abc();
  void abc(){
    System.out.println("instance 메서드");
  }
  // 객체 생성 없이 사용 가능
  // A.bcd();
  static void bcd(){
    System.out.println("static 메서드");
  }
}
```



#### 2-3 `static` 초기화 블록

```java
class A {
  int a;
  static int b;
  
  static { // static 초기화 블록 (정적 필드 초기화는 static{}내에서)
    b=5;
    System.out.println("클래스가 로딩될 때 static block 실행")
  }
  
  A(){ // 인스턴스 필드 초기화는 일반적으로 생성자에서 수행
    a=3;
  }
}
```



