# 23. 물리적 DB설계

>  **일반적인 H/W 업그레이드**
>
>  1. HDD > SSD
>    - 부팅 속도 향상, 일반적 처리 속도 향상
>  2. RAM 업그레이드
>    - Application 로딩 속도 향상
>  3. CPU 업그레이드
>    - 연산속도, 멀티테스킹 향상
>  4. GPU 업그레이드
>    - 그래픽, 빅데이터 처리 향상

---



### 01. Index

- 검색 속도를 향상 시키기 위해 만듦

  1. 데이터가 정렬이 되어 있고, 옆에 row id가 기록 되어 있어서, row id로 테이블의 row를 직접 찾을 수 있음. 검색속도 향상

  2. index를 만들면 index 데이터가 추가되므로 DB사이즈가 더 커진다.

     - index는 보통 데이터가 많아서 검색속도가 느려질 때 만들면 효과적이나, DB사이즈가 더 커진다는 점을 고려
     - 개발자와 관리자의 협업이 필요할 수 있음

  3. PK나  unique를 만들면 index가 자동 생성 됨

     - PK가 select 절에 가장 많이 사용되기 때문
     - unique도 사용빈도가 높음

  4. insert, update, delete 속도는 느려짐 (update가 가장 느림)

     - index를 재조정해야 되기 때문

  5. index에 포함된 데이터의 분포가 작을 수록 효과적

     - 예) gender 컬럼은 남, 여 두가지 값만 존재. 대략 50% 차지

  6. where 절에 나오는 filtering column을 사용해서 index 생성

     - 예) `where dept_id=100;` :arrow_right: dept_id로 index 생성

  7. 효과적인 index 사용을 위해서 기존 query를 수정해야 하는 경우도 있음

     - 예) `where salary*12 > 4000000`
       :arrow_right: `where salary > 4000000/12`

       ```sql
       select * from employee;
       select * from employee where salary*12>40000000; -- index 사용 X
       select * from employee where salary>40000000/12; -- index 사용 O

       create index idx_salary on employee(salary); -- index 생성
       drop index idx_salary; -- index 삭제
       ```

       ​

     - 그러나, Query Optimizer(Oracle에 내장)에 의해서 효과적인 query로 변경 된 후, 실행될 수도 있음 



- **sql이 실행되는 과정**
  - sql이 컴파일 될 때 query optimizer가 쿼리를 분석해서 최적화된 실행계획(Execute plan)을 만들고 실행계획에 따라 실행됨
  - query optimizer의 판단에 맡기는게 기본이지만 개발자의 생각이 우선될 때는 index hint(query hint)를 이용해서 강제지정 실행

```sql
-- 동시 접속자의 일련번호가 겹치지 않도록 오라클이 직접 부여한 번호
create sequence sequence_board; -- 시퀀스, 일련번호 자동 생성
drop table board;

create table board(-- 테이블 생성(board)
    bno number primary key,
    title varchar(100) not null,
    content varchar(2000) not null,
    writer varchar(50) not null,
    wdate date not null
);

-- 예제 데이터 삽입
insert into board values(sequence_board.nextval,'sql이란','sql은...','hkd','2025-03-04');
insert into board values(sequence_board.nextval,'erd란','erd는...','lhi','2025-03-01');

-- 100만건 이상의 데이터를 추가하고 검색 실습
insert into board
select sequence_board.nextval,title,content,writer,wdate from board;

select count(*) from board;

commit;

-- index사용으로 비용과 시간 절감
-- 10F(계획설명)을 확안하면 by inex row라는 옵션이 붙어있는 것을 확인 할 수 있다.
select * from board where bno=1000000;
```



- 데이터가 많을 수록 query optimizer가 만들어진 index를 사용, 적을경우 사용하지 않을 가능성이 있다.

```sql
-- 비용이 많이 드는 상황이 오게 되면
-- (자동 인덱스(Oracle이 만들어주는 index의 이름은 sys로 시작)가 붙는 pk를 제외한 것을 검색할 때)
select * from board where wdate='2025-03-01';
create index idx_wdate on board(wdate); -- 기본값 asc, desc를 하고 싶으면 (wdate desc라고 기재하면 됨)
```

- pk인 bno와 직접 만든 인덱스 wdate의 조건을 둘 다 검색할 시, 둘 다 인덱스를 사용하는 경우도 있다.

  - `select * from board where writer='lhi' and wdate='2025-03-01';`

  - 하나씩 index를 추가해서 검색하는 방법도 있지만, 컬럼을 둘 다 묶는 방법도 있다.

    ```sql
    create index idx_writer on board(writer);
    -- 복합인덱스 활용(속도가 느리다면 복합인덱스를 사용한 향상 가능성 높음)
    create index idx_writer_wdate on board(writer,wdate);
    ```

    - 계획설명(10F)에서 `index_writer_wdate`를 사용하는 것을 확인할 수 있다.

    - 테이블 까지 내려갈 필요 없을 때도 있다.

      ```sql
      select writer, wdate from board
      where writer='lss' and wdate='2025-03-04';
      ```

      - 전체 데이터 사이즈 > 인덱스 사이즈 이므로 인덱스에서 가져오는 것이 더 빠름

> **모든 컬럼으로 index를 만들어 두면 빠르고 편할까?**
>
> - 무조건 모든 컬럼으로 index를 만드는 것이 아니라, query를 분석해서 적절하게 반드시 필요한 것만 생성
> - 인덱스가 많아지면 데이터가 커지기 때문에 무조건 좋은 방법은 아니다.



### 02.정규화

- 정규화(Normalization)
  - RDB는 테이블의 데이터를 중복되지 않게 분리해서 사용
  - PK와 PK가 아닌(비PK) 컬럼의 관계에 대한 이야기
    - 테이블에 pk가 있고, pk가 아닌 컬럼은 pk에 종속적이어야함
      (pk와 직접적 관련이 있어야 한다는 뜻)


- 제1정규화 ~ 제3정규화 (기본)
- 중복 제거, 관계 설정 명확을 위해 분리하는 과정
  - 제 1 정규화
    - 중복된 행의 그룹이 존재하면 분리 (다중 속성 분리)
    - *예) 한 행에서 여러 값을 가지는 전화번호 컬럼은 각각의 값으로 분리하여 새로운 행으로 만들어야 함*
  - 제 2 정규화
    - PK가 복합키일 때 PK가 아닌 컬럼은 PK의 일부에 종속되면 안됨
    - *예) 학생-과목 테이블에서 학생의 이름은 학생 ID에만 의존, 과목 정보는 과목ID에만 의존해야 함*
  - 제 3 정규화
    - PK가 아닌 컬럼이 다른 PK가 아닌 컬럼에 종속되면 안됨(PK에 종속되지 않는 관계 칼럼을 분리)
    - *예) 고객 테이블에서 등급과 할인율이 있다면, 할인율이 기존PK가 아닌 등급에 종속되기 때문에 분리해야 함*
  - BCNF 정규화 (3NF의 확장)
    - PK가 복합키일 경우 PK를 구성하는 컬럼이 다른 컬럼과 관련이 있으면 분리
    - *예) 3NF에서는 비PK칼럼이 PK칼럼에 종속되도록 관계를 해결하는데 이 과정에서* `학생-강의-교수` *과 같은 상태가 발생. BCNF는 모든 결정자가 후보키여야 하므로* `학생-강의`, `강의-교수` *로 분리*
  - 비정규화(Denormalization) / 역정규화
    - 정규화를 거친 이후 성능향상이나 다른 목적(구현편리성, 유지보수편리성 등)으로 정규화를 위배하는 것
- 정규화는 어디까지나 가이드로서, 실무에서는 정규화를 기본으로 하되 경우에 따라 비정규화(Denormalization)도 사용



### 03. 관계 DBMS의 시스템 카탈로그

- 데이터 딕셔너리 라고도 한다.

```sql
-- 시스템 카탈로그
select table_name, column_name, data_type
from user_tab_columns
where table_name='EMPLOYEE'; -- 대문자 검색
```

- `EMPLOYEE` 의 이름을 가진 테이블 불러오기

