<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>array, object</title>
  <script>
    // 배열 내부에 객체를 저장할 수 있다.
    // 학생 목록 배열
    let students = [
      {
        name: "철수", 
        age: 22,
        department: ["컴퓨터공학과", '철학과'],
        show: function(){
          return this.name+":"+this.department;
        }
      },
      {
        name: "영희", 
        age: 23,
        department: '경제학과',
        show: function(){
          return this.name+":"+this.department;
        }
      },
      {
        name: "민수", 
        age: 21,
        department: '영문학과',
        show: function(){
          return this.name+":"+this.department;
        }
      },
    ];
    // 0번째 student의 1번째 department 출력
    // .을 사용하여 객체의 속성에 접근
    // []를 사용하여 배열의 요소에 접근
    document.write(students[0].department[1]+"<br>");
    // 1번째 student의 show() 메소드 호출
    document.write(students[1].show()+"<br>");


    // 객체를 따로 생성해서 배열에 저장
    let student1 = {
      name: "철수", 
      age: 22,
      department: ["컴퓨터공학과", '철학과'],
      show: function(){
        return this.name+":"+this.department;
      }
    };
    let student2 = {
      name: "영희", 
      age: 23,
      department: '경제학과',
      show: function(){
        return this.name+":"+this.department;
      }
    };

    let students2 = [student1, student2];

    // 0번째 student의 1번째 department 출력
    conseole.log(students2[0].department[1]);
    // 1번째 student의 show() 메소드 호출
    console.log(students2[1].show());

    let ourstudents = [
      {name: "철수", age: 22},
      {name: "영희", age: 23},
    ];
    document.write(ourstudents[0].name+"<br>");
    document.write(ourstudents[1].age+"<br>");


    //==========================================
    // 요소 추가&삭제

    // push() 메소드
    let food = ["짜장면", "짬뽕", "탕수육"];
    const newLength = food.push("볶음밥", "군만두"); 
    console.log(`새로운 배열의 길이 ${newLength}`); // 5
    console.log(food); // ["짜장면", "짬뽕", "탕수육", "볶음밥", "군만두"]

    // pop() 메소드
    const lastElement = food.pop(); // 마지막 요소를 제거하고 그 값을 반환
    console.log(`제거된 요소 ${lastElement}`); // 군만두
    console.log(food); // ["짜장면", "짬뽕", "탕수육", "볶음밥"]

    // shift() 메소드
    const firstElement = food.shift(); // 첫 번째 요소를 제거하고 그 값을 반환
    console.log(`제거된 요소 ${firstElement}`); // 짜장면
    console.log(food); // ["짬뽕", "탕수육", "볶음밥"]

    // unshift() 메소드
    const newLength2 = food.unshift("김밥", "떡볶이"); // 배열의 맨 앞에 요소를 추가
    console.log(`새로운 배열의 길이 ${newLength2}`); // 5
    console.log(food); // ["김밥", "떡볶이", "짬뽕", "탕수육", "볶음밥"]

    // slice() 메소드
    const slicedFood = food.slice(1, 3); // 1번 인덱스부터 3번 인덱스 전까지 잘라냄
    const slicedFood2 = food.slice(1); // 1번 인덱스부터 끝까지 잘라냄 (1~)
    console.log(slicedFood); // ["떡볶이", "짬뽕"]
    console.log(slicedFood2); // ["떡볶이", "짬뽕", "탕수육", "볶음밥"]
    // 원본에 변화가 없다
    console.log(food); // ["김밥", "떡볶이", "짬뽕", "탕수육", "볶음밥"]

    // slice() 에서 음수 인덱스 사용
    const slicedFood3 = food.slice(-2); // 뒤에서 2개를 잘라냄
    const slicedFood4 = food.slice(-3, -1); // 뒤에서 3번 인덱스부터 -1번 인덱스 전까지 잘라냄
    console.log(slicedFood3); // ["탕수육", "볶음밥"]
    console.log(slicedFood4); // ["짬뽕", "탕수육"]

    // concat() 메소드
    const arrA = [1, 2, 3];
    const arrB = [4, 5, 6];
    const arrC = arrA.concat(arrB); // arrA와 arrB를 합침 (배열을 연결해서 새로우 배열 생성)
    console.log(arrC); // [1, 2, 3, 4, 5, 6]
    // 원본에 변화가 없다
    console.log(arrA); // [1, 2, 3]
    console.log(arrB); // [4, 5, 6]

    let arrD = {a: 1, b: 2};
    let arrE = arrA.concat(arrD); // arrA와 arrD를 합침 (배열을 연결해서 새로우 배열 생성)
    console.log(arrE); // [1, 2, 3, {a: 1, b: 2}]

    // indexOf() 메소드. 배열의 요소를 찾음. 있으면 index, 없으면 -1
    let arrF = [1, 3, 5, 7, 1];
    console.log(arrF.indexOf(1)); // 0 *처음부터 검색
    console.log(arrF.indexOf(2)); // -1 *없으면 -1리턴
    console.log(arrF.indexOf(1, -1)); // 5 *뒤에서부터 검색
    console.log(arrF.indexOf("3")); // -1 *자료형까지 같아야 검색 됨

    // includes() 메소드. 배열의 요소를 찾음. 있으면 true, 없으면 false
    console.log(arrF.includes(1)); // true
    console.log(arrF.includes("3")); // false

    // findIndex() 메소드. 배열의요소를 찾음. 검색조건을 구현한 callback함수를 사용. 있으면 index, 없으면 -1
    let arr = [1, 3, 5, 6, 8];
    let index = arr.findIndex((item) =>
      item % 2 === 0 ? true : false
    );
    console.log(index); // 3. 6이 2의 배수이므로 3번 인덱스에 위치
    
    // find() 메소드. 배열의요소를 찾음. 검색조건을 구현한 callback함수를 사용. 있으면 요소, 없으면 undefined
    let arrPerson = [
      {name: "철수", age: 22},
      {name: "영희", age: 23},
      {name: "민수", age: 21},
    ];
    let person = arrPerson.find((item) => item.age === 22);
    console.log(person); // {name: "철수", age: 22}. 22세인 사람을 찾음

    // filter() 메소드. 배열의 요소를 찾음. 검색조건을 구현한 callback함수를 사용. 있으면 요소, 없으면 []
    let person2 = arrPerson.filter((item) => item.age > 22);
    console.log(person2); // [{name: "영희", age: 23}]. 22세 이상인 사람을 찾음

    // map() 메소드. 배열의 요소를 변환함. 검색조건을 구현한 callback함수를 사용. 있으면 요소, 없으면 []
    // 배열의 각 요소에 대해 주어진 함수를 호출하고, 그 결과로 새로운 배열을 생성
    let arrG = [1, 2, 3, 4];
    let newArr = arrG.map((item) => item * 3); // 각 요소에 3을 곱함
    console.log(newArr); // [3, 6, 9, 12]. 리턴값이 배열

    // sort() 메소드. 배열의 요소를 정렬함. 기본적으로 문자열로 정렬
    let arr2 = ["b", "a", "c"];
    arr.sort();
    console.log(arr2); // ["a", "b", "c"]
    let arr3 = [10, 5, 3]; // 10이 문자열 "10"으로 취급됨. 
    arr.sort();
    console.log(arr3); // [10, 3, 5]. "10"이 사전순으로 가장 먼저 나옴. 

    // compare() 메서드. 정수값 비교를 위한 비교함수
    function compare(a, b) { // asc
      if (a > b) {
        return 1; // a가 b의 뒤로 감 
      } else if (a < b) {
        return -1; // a가 b의 앞으로 감
      } else {
        return 0; // 자리를 바꾸지 않음
      }
    }
     function compare2(a, b) { // desc
      if (a < b) {
        return 1; // a가 b의 뒤로 감 
      } else if (a > b) {
        return -1; // a가 b의 앞으로 감
      } else {
        return 0; // 자리를 바꾸지 않음
      }
    }

    let arr4 = [10, 5, 3];
    arr4.sort(compare); 
    console.log(arr4); // [3, 5, 10]
    arr4.sort(compare2);
    console.log(arr4); // [10, 5, 3]

    //join() 메서드. 배열의 요소를 모두 연결해서 문자열로 리턴.
    let arr5 = ["안녕", "나는", "홍길동"];
    console.log(arr5.join()); // 안녕,나는,홍길동
    console.log(arr5.join("-")); // 안녕-나는-홍길동

    //reduce() 메서드. 배열의 요소를 하나씩 누산기를 사용해서 처리. 최종결과값 한 개 리턴.
    let arr6 = [1, 2, 3, 4, 5];
    let result = arr6.reduce((acc, item) => acc + item, 0); // acc의 초기값은 0, acc + item 결과값이 다시 acc에 전달됨.
    console.log(result); // 15

  </script>
</head>
<body>
  
</body>
</html>